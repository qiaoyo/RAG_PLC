```st
VAR_INPUT
    IN : oscat_STRING250;
END_VAR

VAR_OUTPUT
    URL_ENCODE : oscat_STRING250;
END_VAR

VAR
    pos_in : INT;
    pos_out : INT;
    stop : INT;
    tb : BYTE;
    pt_out : oscat_aB1_255;
    char : BYTE;
    BUF_TO_STRING : BUF_TO_STRING;
    i : INT;
END_VAR

(* 扫描输入字符串并转换不允许的字符 *)
pos_in := 1;
stop := LEN(IN);
FOR pos_out := 1 TO 250 DO
    char := INT_TO_BYTE(GET_CHAR(IN, pos_in));
    IF pos_in > stop THEN
        EXIT;
    ELSIF IS_URLCHR(char) THEN
        pt_out[pos_out] := char;
        (* 增加输入位置 *)
        pos_in := pos_in + 1;
    ELSE
        (* 无法容纳3个数字，退出 *)
        IF pos_out > 248 THEN EXIT; END_IF;
        (* 无效字符需要转换 *)
        pt_out[pos_out] := BYTE#37; (* 从 % 符号开始 *)
        pos_out := pos_out + 1;
        (* 需要添加两个十六进制数字 *)
        tb := SHR_BYTE(char, 4);
        IF tb > BYTE#9 THEN
            pt_out[pos_out] := USINT_TO_BYTE(BYTE_TO_USINT(tb) + USINT#55);
        ELSE
            pt_out[pos_out] := USINT_TO_BYTE(BYTE_TO_USINT(tb) + USINT#48);
        END_IF;
        pos_out := pos_out + 1;
        tb := char AND BYTE#16#0F;
        IF tb > BYTE#9 THEN
            pt_out[pos_out] := USINT_TO_BYTE(BYTE_TO_USINT(tb) + USINT#55);
        ELSE
            pt_out[pos_out] := USINT_TO_BYTE(BYTE_TO_USINT(tb) + USINT#48);
        END_IF;
        (* 增加输入和输出，因为输出需要移动3个数字 *)
        pos_in := pos_in + 1;
    END_IF;
END_FOR;

pos_out := pos_out - 1;

FOR i := 0 TO 1 DO
    BUF_TO_STRING.REQ := i > 0;
    BUF_TO_STRING.B