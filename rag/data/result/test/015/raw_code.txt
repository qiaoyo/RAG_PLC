```iec
VAR_INPUT
    IN0 : BOOL := TRUE;
    IN1 : BOOL := TRUE;
    IN2 : BOOL := TRUE;
    IN3 : BOOL := TRUE;
    START : BOOL;
    RST : BOOL;
    WAIT0 : TIME;
    DELAY0 : TIME;
    WAIT1 : TIME;
    DELAY1 : TIME;
    WAIT2 : TIME;
    DELAY2 : TIME;
    WAIT3 : TIME;
    DELAY3 : TIME;
    STOP_ON_ERROR : BOOL;
END_VAR

VAR_OUTPUT
    Q0 : BOOL;
    Q1 : BOOL;
    Q2 : BOOL;
    Q3 : BOOL;
    QX : BOOL;
    RUN : BOOL;
    STEP : INT := -1;
    STATUS : BYTE;
END_VAR

VAR
    last : TIME;
    edge : BOOL;
    tx : TIME;
    init : BOOL;
    T_PLC_MS : T_PLC_MS;
END_VAR

(* 读取 SPS 定时器 *)
T_PLC_MS();
tx := UDINT_TO_TIME(T_PLC_MS.T_PLC_MS);

(* 启动时初始化 *)
IF NOT init THEN
    last := tx;
    init := TRUE;
    STATUS := BYTE#110;
END_IF;

(* 异步复位 *)
IF RST THEN
    STEP := -1;
    Q0 := FALSE;
    Q1 := FALSE;
    Q2 := FALSE;
    Q3 := FALSE;
    STATUS := BYTE#110;
    RUN := FALSE;

(* 启动输入的边沿重启顺序 *)
ELSIF START AND NOT edge THEN
    STEP := 0;
    last := tx;
    STATUS := BYTE#111;
    Q0 := FALSE;
    Q1 := FALSE;
    Q2 := FALSE;
    Q3 := FALSE;
    RUN := TRUE;
END_IF;
edge := START;

(* 检查是否需要在状态上停止 *)
IF STATUS > BYTE#0 AND STATUS < BYTE#100 AND STOP_ON_ERROR THEN RETURN; END_IF;

(* 顺序正在运行 *)
IF RUN AND STEP = 0 THEN
    IF NOT Q0 AND IN0 AND tx - last <= WAIT0 THEN
        Q0 := TRUE;
        last := tx;
    ELSIF NOT Q0 AND tx - last > WAIT0 THEN
        STATUS := BYTE#1;
        RUN := FALSE;
    ELSIF Q0 AND tx