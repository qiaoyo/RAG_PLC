import sys
import re
import os

def wrap_st_code(input_path, output_path):
    # 1. 读取 LLM 生成的代码片段
    try:
        with open(input_path, 'r', encoding='utf-8') as f:
            llm_content = f.read().strip()
    except Exception as e:
        print(f"Error reading input file: {e}")
        return

    # 2. 简单的代码清洗：如果 LLM 输出了 Markdown 代码块标签，将其去掉
    # 匹配 ```st ... ``` 或 ```pascal ... ```
    clean_code = re.sub(r'```[a-zA-Z0-9]*', '', llm_content).replace('```', '').strip()

    # 定义固定的名称
    fb_name = "LLM_Wrapper_FB"
    prog_name = "Auto_Proxy_Prg"
    instance_name = "instance"

    # 3. 构造符合 IEC 61131-3 标准的完整 ST 结构
    # 采用：FB 封装逻辑 -> PROGRAM 实例化 FB -> CONFIGURATION 绑定任务
    st_template = f"""
(* =========================================================
   Generated by PLC-Eval Benchmark Wrapper
   ========================================================= *)

FUNCTION_BLOCK {fb_name}
{clean_code}
END_FUNCTION_BLOCK

PROGRAM {prog_name}
  VAR
    {instance_name} : {fb_name};
  END_VAR

  {instance_name}();
END_PROGRAM

CONFIGURATION Config0
  RESOURCE Res0 ON PLC
    TASK TaskMain(INTERVAL := T#20ms, PRIORITY := 0);
    PROGRAM Inst0 WITH TaskMain : {prog_name};
  END_RESOURCE
END_CONFIGURATION
"""

    # 4. 写入输出文件
    try:
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(st_template)
        print("-" * 40)
        print(f"Successfully wrapped code!")
        print(f"Input:  {input_path}")
        print(f"Output: {output_path}")
        print(f"Structure: FB '{fb_name}' -> PROGRAM '{prog_name}'")
        print("-" * 40)
    except Exception as e:
        print(f"Error writing output file: {e}")

if __name__ == "__main__":
    # 检查命令行参数
    if len(sys.argv) != 3:
        print("Usage: python st_wrapper.py <input_text_file> <output_st_file>")
        print("Example: python st_wrapper.py test.txt test_2.st")
    else:
        wrap_st_code(sys.argv[1], sys.argv[2])
